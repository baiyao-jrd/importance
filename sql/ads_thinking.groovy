// 1. 流量主题 - 各渠道流量统计
// 1.1 统计指标 -> 假设5个渠道, 那么每天就是15条数据
//      最近1,7,30天各渠道的访客数、会话数、会话平均停留时长、会话平均浏览页面数、跳出率
// 1.2 指标实现
//      dws层有一张流量域的最近一天会话粒度的聚合统计表, 里面有每个会话在最近一天时间一共浏览了多少页面, 浏览所有页面持续了多长时间, 包括mid
// 
//      1.2.1 lateral view explode(array(1,7,30)) tmp as recent_days 把流量域会话粒度的聚合表扩容到三倍, where条件是
//            dt >= date_sub(当天时间, recent_days - 1), 这样就可以实现最近n天的需求拿最近n天的数据, 然后按照recent_days和渠道分组聚合
//            
//      1.2.2 count(distinct mid)就能得到访客数
//      1.2.3 count(*) 得到会话数 -> 因为原表本来就是会话粒度 
//      1.2.4 avg(每个会话的停留时长)得到会话平均停留时长
//      1.2.5 avg(每个会话的浏览页面数)得到会话的平均浏览页面数
//      1.2.6 sum(if(会话浏览页面数为1, 1, 0)) / count(*) 得到跳出率






// 2. 流量主题 - 用户访问路径分析
// 2.1 统计指标
//      最近1,7,30天从某个起始页面跳转到某个目标页面的跳转次数, 要求起始页面不能为空, 还有就是路径不能存在环路 A -> B -> C -> B
// 2.2 指标实现
//      dwd层有一张流量域的最近一天页面访问增量表, 里面有当天某个会话访问的上个页面是啥, 访问的本页面是啥, 访问时间是啥
// 
//      2.2.1 lateral view explode(array(1,7,30)) tmp as recent_days 把这张dwd层的流量域页面访问表扩容到三倍, where条件是
//            dt >= date_sub(当天时间, recent_days - 1), 这样就可以实现最近n天的需求拿最近n天的数据, 最后按照recent_days,
//            起始页面, 目标页面三个维度聚合, count(*)得到这个路径的次数就行了
// 
//            但需要解决两个问题 1. 起始页面不能为空 2. 整个路径不能有环
//      2.2.2 起始页面就用源表的page_id, 也就是当前页面, 这样起始页面一定不会为空, 这样的话目标页面就使用lead(page_id, 1, null)
//            over(partition by recent_days, session_id order by 页面浏览时间) next_page_id, 同时对每个会话内访问每个页面的
//            阶数做一个统计, 也就是row_number() over(partition by recent_days, session_id order by 页面浏览时间) rn
//      2.2.3 concat(page_id, '_', rn) as 起始页面, concat(next_page_id, '_', rn+1) as 目标页面, 这样就避免了统一会话路径存在环路的问题, 
//            那么最后就按照recent_days, 起始页面, 目标页面三个维度聚合, count(*)得到这个路径的次数就行了






// 3. 用户主题 - 用户变动统计
// 3.1 统计指标 -> 每天1条数据
//      统计当天新增的流失用户数量和当天的回流用户数量
//      新增流失用户: 7天前登录了, 此后1,2,3,4,5,6, 到当天算是第7天了, 当天仍未登录, 那么就算今天的新增流失用户
//      回流用户: 该用户上次登录日期与当天日期只差 >= 8 也就说中间相差至少是7天
// 
// 3.2 指标实现
//      dws层有一张用户域的历史至今的所有用户用户粒度的登录汇总表, 里面有历史到当天的所有每个用户的末次登录日期和登录的次数

//      td表是1d一个分区, 每天分区存的都是历史至今的全部登录记录的汇总表

//      3.2.1 对这张dws历史至今登录汇总表的where条件是dt为当天, 末次登录日期为date_sub(当天, 7), 这样就能表示今天是未登录的第七天, 
//            而7天前的那一天正好是最后一次登录, 这样count(*)就得到了当天的所用新增流失用户数量
//      3.2.2 当天的回流用户更好算, 由于是当天回流了, 所以拿当天的历史至今登录表数据, 每个用户的登录时间肯定是当天, 那我就接着拿
//            dt = date_sub(当天, 1)的数据, 就拿到了上次登录日期, 然后这两张表按照user_id关联, 筛选条件是date_diff(当天, 上次登录日期)
//            大于等于8, 这个关联的基础上count(*)就得到了当天的所有回流用户数
//      3.2.3 将上面得到的新增流失用户数量和回流用户数量按照当天时间关联就得到了今天的新增流失用户数和当天的回流用户数






// 4. 用户主题 - 用户留存率统计
// 4.1 统计指标 -> 每天7条数据
//      统计某一天所有新增用户数与n天后仍然活跃的用户数量的比值 * 100
//      
//      2023-10-08作为当天的数据, 这个数据来了之后就可以计算下面的这所有指标:
//      2023-10-07的1日留存率、2023-10-06的2日留存率、2023-10-05的3日留存率、2023-10-04的4日留存率、
//      2023-10-03的5日留存率、2023-10-02的6日留存率、2023-10-01的7日留存率

// 4.2 指标实现
//      dws层有一张用户域的历史至今的所有用户用户粒度的登录汇总表, 里面有历史到当天的所有每个用户的末次登录日期和登录的次数
//      dwd层有一张用户域的用户注册增量表, 这张表是每天一个分区, 只存放当天的所有注册用户信息

//      4.2.1 因为拿到当天的数据之后, 就要统计前7天每一天的留存率, 那么就得
//            拿dwd层用户域注册增量表前7天的数据, where条件是 dt >= date_sub(当天, 7) and dt < 当天
//            拿dws层用户域登录历史至今表当天的数据
//             
//            上面两张表按照user_id inner join, 同时按照dwd层的用户域注册增量表的注册时间分组聚合

//            我们要拿到注册时间的n日留存率

//      4.2.2 某天的几日, 分组字段是注册时间, 他就是要统计的某天, date_diff(当天, 注册时间) 得到 n 日, 也就是某天的几日留存率
//      4.2.3 这一天新增的用户数量是多少呢, 直接count(*)
//      4.2.4 当天还活跃的用户数量, 也就是留存用户数量是? sum(if(末次登陆日期为当天, 1, 0))
//      4.2.5 得到的留存用户数 / 新增用户数 最后 * 100就得到了留存率






// 5. 用户主题 - 用户新增、活跃统计
// 5.1 统计指标 -> 每天3条数据
//      最近1、7、30天的新增用户数量和活跃用户数量各是多少
//      

// 5.2 指标实现
//      dws层有一张用户域的历史至今的所有用户用户粒度的登录汇总表, 里面有历史到当天的所有每个用户的末次登录日期和登录的次数
//      dwd层有一张用户域的用户注册增量表, 这张表是每天一个分区, 只存放当天的所有注册用户信息

//      5.2.1 lateral view explode(array(1,7,30)) tmp as recent_days 将当天分区的历史至今用户登录表扩容至3倍, 按照recent_days
//            分组, sum(if(末次登录日期 >= date_sub(当天, recent_days - 1)), 1, 0), 也就是末次登录日期在n天内的统计, 得到最近n
//            天的活跃用户数量
//      5.2.2 lateral view explode(array(1,7,30)) tmp as recent_days 将dwd层用户注册表扩容至3倍, 按照recent_days
//            分组, sum(if(注册日期 >= date_sub(当天, recent_days - 1)), 1, 0), 也就是注册日期在n天内的统计, 得到最近n
//            天的新增用户数量
//      5.2.3 两者按照recent_days关联就得到了当天的最近n天的活跃用户数量和新增用户数量






// 6. 用户主题 - 用户行为漏斗分析
// 6.1 统计指标 -> 每天3条数据
//      最近1、7、30天浏览首页的人数、浏览商品详情页的人数、加购人数、下单人数、支付人数  

// 6.2 指标实现
//      dws层有一张流量域的访客页面粒度最近一天页面访问汇总表和最近n天页面访问汇总表

//      6.2.1 对于流量域访客页面粒度最近一天页面访问汇总表, 筛选条件是 dt = 当天 and page_id in (home, good_detail),
//            sum(if(page_id = 'home', 1, 0)) 得到最近一天的首页访问人数, sum(if(page_id = 'good_detail', 1, 0)) 得到
//            最近一天的商品详情页访问人数, 其中recent_days为'1'
//      6.2.2 对于流量域访客页面粒度最近n天页面访问汇总表, 这张表里面, 由于某个访客访问某个页面, 最近30天一定访问过, 但是最近7天有可能没有
//            访问过, 所以里面有两个字段, 一个是最近7天这个页面的访问次数, 一个是最近30天这个页面的访问次数, 所以现在我要把流量域访客页面粒度
//            最近n天页面访问汇总表通过lateral view explode(array(7,30)) tmp as recent_days将表扩容成两倍, 筛选条件是当天的分区, 页面是
//            home或者good_detail, 接着case recent_days when 7 then view_count_7d when 30 then view_count_30d end view_count, 最外层
//            按照recent_days分组, 只要view_count数大于零数量就加一, sum(if(page_id='home' and view_count>0,1,0)) as home_count, 
//            sum(if(page_id='good_detail' and view_count>0,1,0)) as good_detail_count
//      6.2.3 两个结果union all一下

//      dws层有一张交易域的用户粒度最近一天加购汇总表和最近n天加购汇总表, 统计每个用户最近n天的下单次数、件数、金额

//      6.2.4 由于是用户粒度, 所以直接count(*)获得当天的加购人数, 其中recent_days为'1'
//      6.2.5 对于最近n天加购汇总表, 一样, 先炸成2倍, case recent_days when 7 then cart_add_count_7d when 30 then cart_add_count_30d
//            end cart_count, 接着按照recent_days聚合, sum(if(cart_count>0,1,0)) 也就是加购数量大于零的, 总数加一, 最后得到最近n天的加购
//            人数
//      6.2.6 两个结果union all一下
//      6.2.7 下单、支付总人数的计算和加购人数算法一模一样
//      6.2.8 最后将所有结果按照recent_days关联






// 7. 商品主题 - 最近7/30日各品牌复购率统计
// 7.1 统计指标 -> 假设有10个品牌, 那么每天20条数据
//      最近7、30天各个品牌重复下单人数占下单人数的比例, 咱们这里的复购表示重复下单而不是重复购买

// 7.2 指标实现
//      dws层有一张交易域的用户订单商品粒度最近n天汇总表

//      7.2.1 选择当天的表数据, lateral view explode(array(7,30)) tmp as recent_days炸成两倍, case recent_days when 7 then 
//            order_count_7d when 30 then order_count_30d end order_count, 按照recent_days, 用户, 品牌分组聚合, sum(order_count)
//            得到最近n天某个用户购买某个品牌的次数之后外层再按照recent_days, 品牌聚合sum(if(order_count>=2,1,0))/sum(if(order_count>=1,1,0))
//            也就是下单次数超过2次的人数与下单总人数的比值






// 8. 商品主题 - 各分类商品购物车存量Top10统计 
// 8.1 统计指标
//      找出各分类下面购物车存量排行前10的商品

// 8.2 指标实现
//      dwd层有一张交易域的购物车周期快照表, 里面是某个购物车某个用户加购某个商品的件数

//      8.2.1 选择当天分区的数据, 按照sku_id聚合sum(sku_num), 得到某个商品在购物车中的总数量, 然后left join, dim层的商品信息表, 关联
//            字段是sku_id, 商品信息表所选分区是当天, 这样就拿到了商品的一级、二级、三级分类, 最后rank() over (partition by category1_id,
//            category2_id,category3_id order by cart_num desc) rk, 也就是按照1,2,3级分类分区, 按照购物车存量降序排序, 取前十rk <= 10






// 9. 交易主题 - 各省份交易统计
// 9.1 统计指标 -> 34省份 * 3条数据
//      最近1、7、30日各省订单数和订单总金额

// 9.2 指标实现
//      dws层有一张交易域省份粒度的订单聚合最近1天汇总表和最近n天汇总表

//      9.2.1 最近一天的就直接从当天的表里面取订单数和订单总金额, 最近n天的就使用lateral view explode(array(7,30)) tmp as recent_days
//            利用case when, case recent_days when 7 then order_count_7d when 30 then order_count_30d end order_count,或者
//            case recent_days when 7 then order_total_amount_7d when 30 then order_total_amount_30d end order_total_amount
//            分别拿到最近n天的, 最后union all最近1天和最近n天的数据